{
    "contents" : "\n#'@title Anderson-Darling Normality Test (ad.nor)\n#'@description Test for normality\n#'@details Anderson-Darling Normality Test is used to determine whether a set of observations follows ‘Normal Distribution’.  The assumption of ‘Normality’ is widely used in Statistics in the areas of Inferential Statistics, Parametric Methods, Modeling (i.e.) from Simple Linear Regression to advanced Predictive Modeling Techniques.\n#'@param Numeric column position x in the dataframe\n#'@return P-value\n#'@export\n\n\nad.nor <- function (x) \n{\n  \n  options(digits=5,scipen=100)\n  \n  DNAME <- deparse(substitute(x))\n  x <- sort(x[complete.cases(x)])\n  n <- length(x)\n  if (n < 8) \n    stop(\"sample size must be greater than 7\")\n  p <- pnorm((x - mean(x))/sd(x))\n  h <- (2 * seq(1:n) - 1) * (log(p) + log(1 - rev(p)))\n  A <- -n - mean(h)\n  AA <- (1 + 0.75/n + 2.25/n^2) * A\n  if (AA < 0.2) {\n    pval <- 1 - exp(-13.436 + 101.14 * AA - 223.73 * AA^2)\n  }\n  else if (AA < 0.34) {\n    pval <- 1 - exp(-8.318 + 42.796 * AA - 59.938 * AA^2)\n  }\n  else if (AA < 0.6) {\n    pval <- exp(0.9177 - 4.279 * AA - 1.38 * AA^2)\n  }\n  else {\n    pval <- exp(1.2937 - 5.709 * AA + 0.0186 * AA^2)\n  }\n  RVAL <- list(statistic = c(A = A), p.value = pval, method = \"Anderson-Darling normality test\", \n               data.name = DNAME)\n  class(RVAL) <- \"htest\"\n  # return(RVAL)\n  return(pval)\n  \n}\n\n#'@title Graphical Summary(gs)\n#'@description Gives four types of graphical summary Histogram,Box plot,Time series plot and Auto correlation function plot\n\n#'@details Histogram displays the values in Frequency Domain.  Histogram also displays information on Anderson-Darling Normality P-value, Mean (mu) & Standard Deviation (sigma).Time Series Plot, displays the values over Time Domain.  Time Plot displays values of Q1, Q2/Median & Q3.  These values are also displayed in the plot in the form of Horizontal Lines.Box-Whisker Plot, is a Five-Number summary.  Outliers and Skewness of the distribution can be assed using Box-Plot.Auto Correlation Function, shows the significant of each lags.\n#'@param Numeric (column position x in the dataframe)\n#'@return plots\n#'@export\n\ngs <- function(col.pos.x) {\n  \n  options(digits=5,scipen=10)\n  \n  mydata <- data.frame(col.pos.x)\n  col.pos <- 1\n  col.name <- colnames(mydata) [col.pos]\n  \n  par(mfcol=c(2,2))\n  \n  \n  \n  hist(mydata[,col.pos],col='tomato',main=paste('Histogram'),probability=T,xlab=paste('Nor.p.val',round(ad.nor(mydata[,col.pos]),4),'mu=',round(mean(mydata[,col.pos]),4),'sigma=',round(sd(mydata[,col.pos]),4)))\n  \n  rug(mydata[,col.pos])\n  \n  \n  \n  boxplot(mydata[,col.pos],col='purple',horizontal=T,main='Box-Whisker Plot',xlab=paste(' *Min=',min(mydata[,col.pos]),'Max=',max(mydata[,col.pos])))\n  \n  abline(v = mean(mydata[,col.pos]),col='red',lwd=2)\n  \n  xlab.v <- paste('Q1=',quantile(mydata[,col.pos],.25),'Q2/Median=',median(mydata[,col.pos]),'Q3=',quantile(mydata[,col.pos],.75))\n  \n  plot(mydata[,col.pos],type='b',main='Time Plot',ylab=col.name,xlab=xlab.v,col='purple')\n  \n  abline(h = median(mydata[,col.pos]),col='red')\n  abline(h = quantile(mydata[,col.pos],.25),col='red')\n  abline(h = quantile(mydata[,col.pos],.75),col='red')\n  \n  acf(mydata[,col.pos],main='Auto Correlation Function',col='red',type = 'correlation')\n  \n  title(paste('Graphical Summary of ',col.name),line = -1,outer = TRUE)\n  \n}\n\n\n\n\n\n\n#'@title Deviations (my.deviate)\n#'@description This functions addresses Deviation, MAD & MSD.\n#'@param Four numeric parameters Parameter 1: It is a column of a Data Frame,Parameter 2: If the second parameter = 1, it then displays DEVIATIONS for each observation,Parameter 3: If the third parameter = 1, it then displays column required to compute MAD,Parameter 4: If the fourth parameter = 1, it then displays column required to compute MSD\n#'@return Displays the computed columns\n#'@export \nmy.deviate <- function(col.pos.x,Deviate=0,MeanAbsDeviation=1,MeanSqDev=0) {\n  \n  col.pos <- as.numeric(1) # changes finalised\n  mydata <- data.frame(col.pos.x) # changes finalised\n  \n  \n  \n  my.matrix <- data.frame(matrix(data = 0,nrow = nrow(mydata),ncol = 3))\n  \n  my.mean <- mean(mydata[,col.pos])\n  \n  for (t in 1:nrow(mydata)) {\n    \n    if(Deviate==1) {\n      my.matrix[t,1] <- mydata[t,col.pos] - my.mean } # End of Deviate\n    \n    if(MeanAbsDeviation==1) {\n      my.matrix[t,2] <- abs(mydata[t,col.pos] - my.mean) } # End of MAD\n    \n    if(MeanSqDev==1) {\n      my.matrix[t,3] <- (mydata[t,col.pos] - my.mean) ^ 2 } # End of MSD\n    \n    \n  }\n  \n  \n  \n  my.args <- array(data = 1,dim = c(6,1))\n  my.args[3] <- MeanSqDev\n  my.args[2] <- MeanAbsDeviation\n  my.args[1] <- Deviate\n  \n  my.args[6] <- \"cMSD\"\n  my.args[5] <- \"cMAD\"\n  my.args[4] <- \"cDEV\"\n  \n  for (t in 1:3) {\n    \n    if (my.args[t]==1) {\n      mydata <- data.frame(mydata,my.matrix[,t])\n      colnames(mydata) [ncol(mydata)] <- paste(names(mydata[1]),\"_\",my.args[t+3],sep = \"\")\n    }\n    \n  }\n  \n  return (mydata)\n}\n\n\nmad.d <- function(col.poss) {\n  \n  temp <- my.deviate(col.pos = col.poss,Deviate = 0,MeanAbsDeviation = 1,MeanSqDev = 0)\n  \n  return(sum(temp[,ncol(temp)]) / nrow(temp))\n  \n}\n\n\nmsd.d <- function(col.poss) {\n  \n  temp <- my.deviate(col.pos = col.poss,Deviate = 0,MeanAbsDeviation = 0,MeanSqDev = 1)\n  \n  return(sum(temp[,ncol(temp)]) / nrow(temp))\n  \n}\n\n\n\n\n#'@title Creating Indicator Variables (create.iv)\n#'@description Creates three types of indicator variables \n#'@details Indicator Variables is a method that is widely used in modeling particularly to handle data that are NOMINAL in nature.  It converts NOMINAL data into a meaningful numerical variables knows as ‘Indicator Variables’ (IV).  The other names for Indicator Variables are also known as Dummy Variables (DV).At times, Indicator Variables (IV) were rarely applied even on NOMINAL data, to convert them into meaningful numerical variables.Indicator Variables (IVs) is widely applied in Regression Techniques, Machine Learning Techniques & Multivariate Techniques such as Cluster Analysis, etc.\n#'@param Numeric column position x in the dataframe and the type of indicator variable For REFERENCE CODING use ‘0’ ,ForEFFECT CODING use ‘-1’,For NO Y-INTERCEPT use ‘1’\n#'@return Indicator Variables Columns\n#'@export\n\ncreate.iv <- function(col.pos.x,iv.type) {\n  \n  mydata <- col.pos.x # recent insertion *parameter col.pos.x was col.pos\n  col.pos <- 1 # recent insertion\n  \n  iv.colnam <- colnames(mydata) [col.pos]\n  iv.uv <- data.frame(unique(mydata[,col.pos]))\n  colnames(iv.uv) [1] <- colnames(mydata) [col.pos]\n  \n  \n  if(iv.type==0) { # Base ZERO coding style\n    \n    temp.mat <- matrix(data = 0,nrow = nrow(mydata),ncol=(nrow(iv.uv)-1))\n    temp.mat <- data.frame(temp.mat)\n    \n    for (i in 1:(nrow(iv.uv)-1)) {\n      colnames(temp.mat) [i] <- paste(iv.colnam,i,sep = \"_\")\n    }\n    \n    for (j in 1:nrow(mydata)) {\n      \n      for (k in 1:(nrow(iv.uv)-1)) {\n        \n        if(mydata[j,col.pos]==iv.uv[k+1,1]) {\n          temp.mat[j,k] <- 1\n        }\n        \n      }\n      \n    }\n  } else {\n    \n    if(iv.type==1) { # n * n MATRIX coding style\n      \n      \n      temp.mat <- matrix(data = 0,nrow = nrow(mydata),ncol=(nrow(iv.uv)-0))\n      temp.mat <- data.frame(temp.mat)\n      \n      for (i in 1:(nrow(iv.uv)-0)) {\n        colnames(temp.mat) [i] <- paste(iv.colnam,iv.uv[i,1],sep = \"_\")\n      }\n      \n      for (j in 1:nrow(mydata)) {\n        \n        for (k in 1:(nrow(iv.uv)-0)) {\n          \n          if(mydata[j,col.pos]==iv.uv[k+0,1]) {\n            temp.mat[j,k] <- 1\n          }\n          \n        }\n        \n      } } else {\n        \n        \n        if(iv.type==-1) { # Average coding style\n          \n          temp.mat <- matrix(data = 0 ,nrow = nrow(mydata),ncol=(nrow(iv.uv)-1))\n          temp.mat <- data.frame(temp.mat)\n          \n          for (i in 1:(nrow(iv.uv)-1)) {\n            colnames(temp.mat) [i] <- paste(iv.colnam,i,sep = \"_\")\n          }\n          \n          for (j in 1:nrow(mydata)) {\n            \n            for (k in 1:(nrow(iv.uv)-1)) {\n              \n              if(mydata[j,col.pos]==iv.uv[1,1])   {\n                temp.mat[j,k] <- -1\n              }   else {                             \n                \n                \n                if(mydata[j,col.pos]==iv.uv[k+1,1]) {\n                  temp.mat[j,k] <- 1               \n                } \n              }\n              \n              \n              \n              \n            }\n            \n          }\n        } }\n  }\n  \n  \n  mydata <- cbind(mydata,temp.mat)\n  \n  return(mydata) \n}\n\n\n\n# xTOz\n#'@title XtoZ (stdZ)\n#'@description Standardize \n#'@details Transforms originalvalue into its respective \"Z\" value\n#'@param Numeric column position x in the dataframe \n#'@return Returns standardized column\n#'@export\n\nstdZ <- function(pos.x,replace=0) {\n  \n  mydata <- pos.x # recent insertion\n  pos <- 1 # recent insertion\n  \n  f.o <- scale(mydata[,pos],center = T,scale = T)\n  \n  if (replace==0) {\n    mydata <- data.frame(mydata,\"TEMP\"=f.o)\n    colnames(mydata) [ncol(mydata)] <- paste(colnames(mydata) [pos],\".Z\",sep = \"\")\n  } else {\n    \n    mydata[,pos] <- f.o\n    colnames(mydata) [pos] <- paste(colnames(mydata) [pos],\".Z\",sep = \"\")\n  }\n  \n  return(mydata)\n  \n}\n\n\n\n#'@title  Skewness (ske)\n#'@description Measure of Descriptive Statistics\n#'@details Skewness addresses the characteristics of symmetry.\n#'@param Numeric column position x in the dataframe\n#'@return Gives the skewness value\n#'@export\n\nske <- function(column.pos) {\n  \n  val <- 0\n  \n  temp <- my.deviate(col.pos=column.pos,Deviate = 1,MeanAbsDeviation = 0,MeanSqDev = 0)\n  tot.col <- ncol(temp)\n  temp.sd <- sd(temp[,tot.col])\n  tot.row <- nrow(temp)\n  \n  for(t in 1:tot.row) {\n    val <- val + ((temp[t,tot.col] / temp.sd) ^ 3)\n  } \n  return((tot.row) / ((tot.row-1) * (tot.row-2)) * val) \n}\n\n\n\n# \n#'@title Kurtosis (kur)\n#'@description Measure of Descriptive Statistics\n#'@details Kurtosis addresses the characteristics of ‘Peakedness’ & ‘Taildness’.\n#'@param Numeric (column position x in the dataframe)\n#'@return Gives the kurtosis value\n#'@export\n\n\nkur <- function(column.pos) {\n  \n  val <- 0\n  \n  temp <- my.deviate(col.pos=column.pos,Deviate = 1,MeanAbsDeviation = 0,MeanSqDev = 0)\n  tot.col <- ncol(temp)\n  temp.sd <- sd(temp[,tot.col])\n  tot.row <- nrow(temp)\n  \n  for(t in 1:tot.row) {\n    val <- val + ((temp[t,tot.col] / temp.sd) ^ 4)\n  } \n  \n  p1 <- tot.row * (tot.row+1)\n  p2 <- (tot.row-1) * (tot.row-2) * (tot.row-3)\n  p3 <- 3 * ((tot.row-1)^2)\n  p4 <- (tot.row-2) * (tot.row-3)\n  \n  return(((p1/p2) * val) - (p3/p4))\n  \n}\n\n\n\n\noptimal.lamda <- function(col.pos.x,my.alpha=0.05) {\n  \n  mydata <- col.pos.x # recent insertion\n  col.pos <- 1\n  \n  options(scipen=100)\n  my.row.id <- 0\n  my.matrix <- data.frame(matrix(data = 0,nrow = 400 ,ncol = 2))\n  \n  for (j in seq(from = -2,to = 2,by = .01)) {\n    \n    if(j==0) {\n      \n    } else {\n      \n      my.row.id <- (my.row.id+1)\n      \n      my.matrix[my.row.id,1] <- as.numeric(j)\n      \n      \n      my.matrix[my.row.id,2] <- as.numeric(ad.nor((mydata[,col.pos]^j)))\n      \n    }\n  }\n  \n  if(round(my.matrix[which.max(my.matrix[,2]),1],digits = 4)<my.alpha) {\n    return(0) } else {\n      return(round(my.matrix[which.max(my.matrix[,2]),1],digits = 4))\n      \n    }\n}\n\n\n\n#'@title  Box-Cox Transformation (boxcox.t)\n#'@description  Box-Cox Power Transformations from Non-Normal to Normality\n#'@details Box-Cox transformation is usually applied in order to achieve modeling assumptions.  As stated earlier techniques such as Simple Linear Regression, Multiple Linear Regression, Logistic Regression and other Classification Techniques like Discriminant Analysis, DT, NN, etc., also requires data to be normally distributed.(E.g.) In ENERGY model building, the usage of ENERGY in any house, district or state will be right-skewed.  Using Box-Cox when the same is transformed into ‘NORMAL’ the assumption is met, at the same time after transformation that particular units will lose its original UNIT OF MEASUREMENT.\n#'@param Numeric column position x in the dataframe\n#'@return Returns optimal lambda value and transformed column vector\n#'@export\n\nboxcox.t <- function(your.object) {\n  \n  cat('\\n','Optimal Lamda = ',optimal.lamda(your.object),'\\n')\n  return(your.object^optimal.lamda(your.object))  \n  \n}\n\n\n\n#'@title Transformation of Poisson Data (poi.trans)\n#'@description  Freeman Tukey Variance Stabilization transformation for POISSON DISTRIBUTION DATA\n#'@details This technique widely used to Stabilize Variance during model building.if the COUNT data follows Poisson Distribution, this transformation is then applied.\n#'@param Numeric column position x in the dataframe\n#'@return Returns transformed column vector\n#'@export \npoi.trans <- function(your.object) {\n  options(digits=6)\n  mydata <- your.object\n  \n  mydata.poi.trans <- ((mydata^0.5) +  ((mydata+1)^0.5)) / 2\n  \n  mydata <- data.frame(cbind(mydata,mydata.poi.trans))\n  colnames(mydata) [2] <- paste(names(your.object),'.POISSONtrans',sep = \"\")\n  \n  return (mydata)\n  \n}\n\n\n\n#\n#'@title Transformation of Proportion Data (prop.trans)\n#'@description Freeman Tukey Arcsin Transformation For Proportions\n#'@details This technique is widely used to Stabilize Variance during model building.  The proportion should be arrived from a COUNT data only.  It should not be applied under scenarios like where the Proportion is arrived from Continuous Data.  Should not be applied for Profit Margins.\n#'@param Numeric column position x in the dataframe\n#'@return Returns transformed column vector\n#'@export \n\nprop.trans <- function(your.object) {\n  options(digits=6)\n  mydata <- your.object\n  \n  mydata.prop.trans <- asin(mydata^0.5) \n  \n  mydata <- data.frame(cbind(mydata,mydata.prop.trans))\n  colnames(mydata) [2] <- paste(names(your.object),'.PROPORTIONtrans',sep = \"\")\n  \n  return (mydata)\n  \n}\nx<-c(.3,.76,.45)\nprop.trans(x)\n\n\n\n",
    "created" : 1414994293142.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3160883104",
    "id" : "30471070",
    "lastKnownWriteTime" : 1415000759,
    "path" : "~/Dropbox/premod/R/code.R",
    "project_path" : "R/code.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}