{
    "contents" : "\n#\n\n\n\nad.nor <- function (x) \n{\n  \n  options(digits=5,scipen=100)\n  \n  DNAME <- deparse(substitute(x))\n  x <- sort(x[complete.cases(x)])\n  n <- length(x)\n  if (n < 8) \n    stop(\"sample size must be greater than 7\")\n  p <- pnorm((x - mean(x))/sd(x))\n  h <- (2 * seq(1:n) - 1) * (log(p) + log(1 - rev(p)))\n  A <- -n - mean(h)\n  AA <- (1 + 0.75/n + 2.25/n^2) * A\n  if (AA < 0.2) {\n    pval <- 1 - exp(-13.436 + 101.14 * AA - 223.73 * AA^2)\n  }\n  else if (AA < 0.34) {\n    pval <- 1 - exp(-8.318 + 42.796 * AA - 59.938 * AA^2)\n  }\n  else if (AA < 0.6) {\n    pval <- exp(0.9177 - 4.279 * AA - 1.38 * AA^2)\n  }\n  else {\n    pval <- exp(1.2937 - 5.709 * AA + 0.0186 * AA^2)\n  }\n  RVAL <- list(statistic = c(A = A), p.value = pval, method = \"Anderson-Darling normality test\", \n               data.name = DNAME)\n  class(RVAL) <- \"htest\"\n  # return(RVAL)\n  return(pval)\n  \n}\n\n#' Graphical Summary(gs)\n#' Input: gs(data.frame[column position])\n#'Output: Graphs of Histogram, Time-Plot, Box-Whisker Plot & Auto CorrelationFunction\n#'@param X   Numeric column position in dataframe\n#'@return    plots\n#'@export\n\ngs <- function(col.pos.x) {\n  \n  options(digits=5,scipen=10)\n  \n  mydata <- data.frame(col.pos.x)\n  col.pos <- 1\n  col.name <- colnames(mydata) [col.pos]\n  \n  par(mfcol=c(2,2))\n  \n  \n  # par(bg='tomato')\n  #his.density <- max(hist(mydata[,col.pos],prob=T)$density)\n  # y.max.his <- dnorm(mean(mydata[,1]),mean(mydata[,1]),sd(mydata[,1]))\n  \n  hist(mydata[,col.pos],col='tomato',main=paste('Histogram'),probability=T,xlab=paste('Nor.p.val',round(ad.nor(mydata[,col.pos]),4),'mu=',round(mean(mydata[,col.pos]),4),'sigma=',round(sd(mydata[,col.pos]),4)))\n  \n  rug(mydata[,col.pos])\n  \n  #   points(mydata[,col.pos],dnorm(mydata[,col.pos],mean(iris[,1]),sd(mydata[,col.pos])),cex=.5)\n  \n  \n  boxplot(mydata[,col.pos],col='purple',horizontal=T,main='Box-Whisker Plot',xlab=paste(' *Min=',min(mydata[,col.pos]),'Max=',max(mydata[,col.pos])))\n  \n  abline(v = mean(mydata[,col.pos]),col='red',lwd=2)\n  \n  xlab.v <- paste('Q1=',quantile(mydata[,col.pos],.25),'Q2/Median=',median(mydata[,col.pos]),'Q3=',quantile(mydata[,col.pos],.75))\n  \n  plot(mydata[,col.pos],type='b',main='Time Plot',ylab=col.name,xlab=xlab.v,col='purple')\n  \n  abline(h = median(mydata[,col.pos]),col='red')\n  abline(h = quantile(mydata[,col.pos],.25),col='red')\n  abline(h = quantile(mydata[,col.pos],.75),col='red')\n  \n  acf(mydata[,col.pos],main='Auto Correlation Function',col='red',type = 'correlation')\n  \n  title(paste('Graphical Summary of ',col.name),line = -1,outer = TRUE)\n  \n}\n\n# OVA\n\n\nova <- function(dat,myalpha=.05) {\n  \n  \n  plot.new()\n  \n  col.pos <- data.frame(dat)\n  \n  r <- sample(0:255,1,replace=F)\n  g <- sample(0:255,1,replace=F)\n  b <- sample(0:255,1,replace=F)\n  \n  # par(bg,col=34)\n  # hist(y,col=rgb(r,g,b,maxColorValue=255))\n  \n  print(quantile(dat,c(0,seq(1:100)/100)))\n  cat('\\n')\n  cat('Mean = ',mean(dat),'SD = ',sd(dat),'Var = ',var(dat),'\\n')\n  cat('IQR = ',quantile(dat,.75)-quantile(dat,.25),'SF = ',quantile(dat,.25)/quantile(dat,.75),'\\n')\n  cat('Skewness = ',ske(dat),'Kurtosis = ',kur(dat))\n  \n  par(mfcol=c(1,1))\n  par(fig=c(0,1,0,0.6), new=TRUE)\n  hisheight <- max(dnorm(dat,mean(dat),sd(dat)))\n  hisheight <- (hisheight*1.5)\n  hist(dat,main='',probability=T,xlab='',col=rgb(r,g,b,maxColorValue=255),ylim = c(0, hisheight))\n  \n  points(x=sort(dat),y=dnorm(sort(dat),mean(dat),sd(dat)),type='l',col='red')\n  \n  \n  par(fig=c(0,1,0.30,0.8), new=TRUE)\n  boxplot(dat,horizontal=T,main='',col=rgb(g,b,r,maxColorValue=255),axes=FALSE)\n  \n  par(fig=c(0,1,0.55,1), new=TRUE)\n  plot(dat,type='b',main='',cex=.35,xlab='',col='red',ylab='')\n  points(dat,type='l',main='')\n  points(x=seq(1:length(dat)),y=rep(median(dat),length(dat)+0),type='l',col='darkgreen')\n  mtext(col='red',\"Single Variable Analysis using\", side=3, outer=TRUE, line=-2)\n  mtext(col='blue',\"Time Plot with Median - Box Plot - Histogram with Normal Curve \", side=3, outer=TRUE, line=-3) \n  cat('\\n','RGB',r,g,b,'\\n')\n  par(mfcol=c(1,1),new=F)\n}\n\n# Deviations Columns and Computed\n\nmy.deviate <- function(col.pos.x,Deviate=0,MeanAbsDeviation=1,MeanSqDev=0) {\n  \n  col.pos <- as.numeric(1) # changes finalised\n  mydata <- data.frame(col.pos.x) # changes finalised\n  \n  # colnames(mydata) [1]  <- names(mydata[1]) # shall be removed at a later point of time\n  \n  my.matrix <- data.frame(matrix(data = 0,nrow = nrow(mydata),ncol = 3))\n  \n  #   colnames(my.matrix) [1] <- paste(colnames(mydata) [col.pos],\"_cDEV\",sep = \"\") # shall be removed at a later point of time\n  #   colnames(my.matrix) [2] <- paste(colnames(mydata) [col.pos],\"_cMAD\",sep = \"\") # shall be removed at a later point of time\n  #   colnames(my.matrix) [3] <- paste(colnames(mydata) [col.pos],\"_cMSD\",sep = \"\") # shall be removed at a later point of time\n  \n  my.mean <- mean(mydata[,col.pos])\n  \n  for (t in 1:nrow(mydata)) {\n    \n    if(Deviate==1) {\n      my.matrix[t,1] <- mydata[t,col.pos] - my.mean } # End of Deviate\n    \n    if(MeanAbsDeviation==1) {\n      my.matrix[t,2] <- abs(mydata[t,col.pos] - my.mean) } # End of MAD\n    \n    if(MeanSqDev==1) {\n      my.matrix[t,3] <- (mydata[t,col.pos] - my.mean) ^ 2 } # End of MSD\n    \n    \n  }\n  \n  #   mydata <- cbind(mydata,my.matrix)\n  \n  my.args <- array(data = 1,dim = c(6,1))\n  my.args[3] <- MeanSqDev\n  my.args[2] <- MeanAbsDeviation\n  my.args[1] <- Deviate\n  \n  my.args[6] <- \"cMSD\"\n  my.args[5] <- \"cMAD\"\n  my.args[4] <- \"cDEV\"\n  \n  for (t in 1:3) {\n    \n    if (my.args[t]==1) {\n      mydata <- data.frame(mydata,my.matrix[,t])\n      # colnames(mydata) [ncol(mydata)] <- paste(colnames(mydata) [col.pos],\"_\",my.args[t+3],sep = \"\")\n      colnames(mydata) [ncol(mydata)] <- paste(names(mydata[1]),\"_\",my.args[t+3],sep = \"\")\n    }\n    \n  }\n  \n  return (mydata)\n}\n\n\nmad.d <- function(col.poss) {\n  \n  temp <- my.deviate(col.pos = col.poss,Deviate = 0,MeanAbsDeviation = 1,MeanSqDev = 0)\n  \n  return(sum(temp[,ncol(temp)]) / nrow(temp))\n  \n}\n\n\nmsd.d <- function(col.poss) {\n  \n  temp <- my.deviate(col.pos = col.poss,Deviate = 0,MeanAbsDeviation = 0,MeanSqDev = 1)\n  \n  return(sum(temp[,ncol(temp)]) / nrow(temp))\n  \n}\n\n# Create IVs using different methods\n\ncreate.iv <- function(col.pos.x,iv.type) {\n  \n  mydata <- col.pos.x # recent insertion *parameter col.pos.x was col.pos\n  col.pos <- 1 # recent insertion\n  \n  iv.colnam <- colnames(mydata) [col.pos]\n  iv.uv <- data.frame(unique(mydata[,col.pos]))\n  colnames(iv.uv) [1] <- colnames(mydata) [col.pos]\n  \n  \n  if(iv.type==0) { # Base ZERO coding style\n    \n    temp.mat <- matrix(data = 0,nrow = nrow(mydata),ncol=(nrow(iv.uv)-1))\n    temp.mat <- data.frame(temp.mat)\n    \n    for (i in 1:(nrow(iv.uv)-1)) {\n      colnames(temp.mat) [i] <- paste(iv.colnam,i,sep = \"_\")\n    }\n    \n    for (j in 1:nrow(mydata)) {\n      \n      for (k in 1:(nrow(iv.uv)-1)) {\n        \n        if(mydata[j,col.pos]==iv.uv[k+1,1]) {\n          temp.mat[j,k] <- 1\n        }\n        \n      }\n      \n    }\n  } else {\n    \n    if(iv.type==1) { # n * n MATRIX coding style\n      \n      \n      temp.mat <- matrix(data = 0,nrow = nrow(mydata),ncol=(nrow(iv.uv)-0))\n      temp.mat <- data.frame(temp.mat)\n      \n      for (i in 1:(nrow(iv.uv)-0)) {\n        colnames(temp.mat) [i] <- paste(iv.colnam,iv.uv[i,1],sep = \"_\")\n      }\n      \n      for (j in 1:nrow(mydata)) {\n        \n        for (k in 1:(nrow(iv.uv)-0)) {\n          \n          if(mydata[j,col.pos]==iv.uv[k+0,1]) {\n            temp.mat[j,k] <- 1\n          }\n          \n        }\n        \n      } } else {\n        \n        \n        if(iv.type==-1) { # Average coding style\n          \n          temp.mat <- matrix(data = 0 ,nrow = nrow(mydata),ncol=(nrow(iv.uv)-1))\n          temp.mat <- data.frame(temp.mat)\n          \n          for (i in 1:(nrow(iv.uv)-1)) {\n            colnames(temp.mat) [i] <- paste(iv.colnam,i,sep = \"_\")\n          }\n          \n          for (j in 1:nrow(mydata)) {\n            \n            for (k in 1:(nrow(iv.uv)-1)) {\n              \n              if(mydata[j,col.pos]==iv.uv[1,1])   {\n                temp.mat[j,k] <- -1\n              }   else {                             \n                \n                \n                if(mydata[j,col.pos]==iv.uv[k+1,1]) {\n                  temp.mat[j,k] <- 1               \n                } \n              }\n              \n              \n              \n              \n            }\n            \n          }\n        } }\n  }\n  \n  \n  mydata <- cbind(mydata,temp.mat)\n  \n  return(mydata) \n}\n\n# xTOz\n\n\nstdZ <- function(pos.x,replace=0) {\n  \n  mydata <- pos.x # recent insertion\n  pos <- 1 # recent insertion\n  \n  f.o <- scale(mydata[,pos],center = T,scale = T)\n  \n  if (replace==0) {\n    mydata <- data.frame(mydata,\"TEMP\"=f.o)\n    colnames(mydata) [ncol(mydata)] <- paste(colnames(mydata) [pos],\".Z\",sep = \"\")\n  } else {\n    \n    mydata[,pos] <- f.o\n    colnames(mydata) [pos] <- paste(colnames(mydata) [pos],\".Z\",sep = \"\")\n  }\n  \n  return(mydata)\n  \n}\n\n\n# Empirical Simulation\n\n# my.levels <- c('gold','silver','bronze')\n# my.actuals <- c(15,20,65)\n# \n# my.column.position <- 18\n# my.per <- 0\n# \n# for (j in 1:length(my.actuals)) {\n#   \n#   if (j==1) {\n#     my.per <- my.actuals[j]/sum(my.actuals)\n#   }\n#   else\n#   {\n#     my.per <- rbind(my.per,my.actuals[j]/sum(my.actuals))\n#   }\n#   \n# }\n# \n# my.dat <- data.frame(my.levels,my.actuals,my.per)\n# my.dat <- my.dat[order(my.per),]\n# my.cumper <- my.dat[1,3]\n# \n# for (k in 2:length(my.actuals)) {\n#   \n#   if (k==2) {\n#     my.cumper <- rbind(my.cumper,my.cumper+my.dat[k,3])\n#   }\n#   else\n#   {\n#     my.cumper <- rbind(my.cumper,my.cumper[k-1]+my.dat[k,3])\n#   }\n# }\n# \n# my.dat <- data.frame(my.dat,my.cumper)\n# my.dat <- data.frame(my.dat,row.names=NULL)\n# \n# my.dat[,1] <- as.character(my.dat[,1])\n# \n# \n# my.fillfile <- hipoc\n# my.targetcol <- my.column.position\n# my.fillfilecol <- c('')\n# \n# for (g in 1:nrow(my.fillfile)) {\n#   rn <- runif(1)\n#   for (w in 1:nrow(my.dat)) \n#   {\n#     if (rn <= my.dat[w,4]) \n#     {\n#       my.fillfilecol <- rbind(my.fillfilecol,my.dat[w,1])\n#       #                                             my.fillfile[g,my.fillfilecol] <- as.character(my.dat[w,1])\n#       #                                             cat('\\n',my.dat[w,1],w,g,rn)\n#       #                                             cat('\\n',my.fillfile[g,my.fillfilecol])\n#       break\n#     }\n#     \n#   }\n#   \n#   if (g==nrow(my.fillfile))\n#   {\n#     my.fillfilecol <- my.fillfilecol[-1,]\n#     my.fillfile[,my.targetcol] <- my.fillfilecol\n#     hipoc[,my.targetcol] <- my.fillfilecol # *** change the receiving file name\n#     # rm(g,j,k,my.actuals,my.fillfilecol,my.levels,my.targetcol,rn,w,my.per)\n#     \n#   }\n#   \n# }\n\n\n# Skewness\n\nske <- function(column.pos) {\n  \n  val <- 0\n  \n  temp <- my.deviate(col.pos=column.pos,Deviate = 1,MeanAbsDeviation = 0,MeanSqDev = 0)\n  tot.col <- ncol(temp)\n  temp.sd <- sd(temp[,tot.col])\n  tot.row <- nrow(temp)\n  \n  for(t in 1:tot.row) {\n    val <- val + ((temp[t,tot.col] / temp.sd) ^ 3)\n  } \n  return((tot.row) / ((tot.row-1) * (tot.row-2)) * val) \n}\n\n# Kurtosis\n\nkur <- function(column.pos) {\n  \n  val <- 0\n  \n  temp <- my.deviate(col.pos=column.pos,Deviate = 1,MeanAbsDeviation = 0,MeanSqDev = 0)\n  tot.col <- ncol(temp)\n  temp.sd <- sd(temp[,tot.col])\n  tot.row <- nrow(temp)\n  \n  for(t in 1:tot.row) {\n    val <- val + ((temp[t,tot.col] / temp.sd) ^ 4)\n  } \n  \n  p1 <- tot.row * (tot.row+1)\n  p2 <- (tot.row-1) * (tot.row-2) * (tot.row-3)\n  p3 <- 3 * ((tot.row-1)^2)\n  p4 <- (tot.row-2) * (tot.row-3)\n  \n  return(((p1/p2) * val) - (p3/p4))\n  \n}\n\n# Finding OPTIMAL LAMDA value for Box-Cox Power transformations\n\noptimal.lamda <- function(col.pos.x,my.alpha=0.05) {\n  \n  mydata <- col.pos.x # recent insertion\n  col.pos <- 1\n  \n  options(scipen=100)\n  my.row.id <- 0\n  my.matrix <- data.frame(matrix(data = 0,nrow = 400 ,ncol = 2))\n  \n  for (j in seq(from = -2,to = 2,by = .01)) {\n    \n    if(j==0) {\n      \n    } else {\n      \n      my.row.id <- (my.row.id+1)\n      \n      my.matrix[my.row.id,1] <- as.numeric(j)\n      \n      \n      my.matrix[my.row.id,2] <- as.numeric(ad.nor((mydata[,col.pos]^j)))\n      \n    }\n  }\n  \n  if(round(my.matrix[which.max(my.matrix[,2]),1],digits = 4)<my.alpha) {\n    return(0) } else {\n      return(round(my.matrix[which.max(my.matrix[,2]),1],digits = 4))\n      \n    }\n}\n\n# Box-Cox Power Transformations from Non-Normal to Normality\n\nboxcox.t <- function(your.object) {\n  \n  cat('\\n','Optimal Lamda = ',optimal.lamda(your.object),'\\n')\n  return(your.object^optimal.lamda(your.object))  \n  \n}\n\n# Freeman Tukey Variance Stabilization for POISSON DISTRIBUTION DATA\n\npoi.trans <- function(your.object) {\n  options(digits=6)\n  mydata <- your.object\n  \n  mydata.poi.trans <- ((mydata^0.5) +  ((mydata+1)^0.5)) / 2\n  \n  mydata <- data.frame(cbind(mydata,mydata.poi.trans))\n  colnames(mydata) [2] <- paste(names(your.object),'.POISSONtrans',sep = \"\")\n  \n  return (mydata)\n  \n}\n\n\n\n#Freeman Tukey Arcsin Transformation For Proportions\n\nprop.trans <- function(your.object) {\n  options(digits=6)\n  mydata <- your.object\n  \n  mydata.prop.trans <- asin(mydata^0.5) \n  \n  mydata <- data.frame(cbind(mydata,mydata.prop.trans))\n  colnames(mydata) [2] <- paste(names(your.object),'.PROPORTIONtrans',sep = \"\")\n  \n  return (mydata)\n  \n}\nx<-c(.3,.76,.45)\nprop.trans(x)\n",
    "created" : 1414754774908.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "286370045",
    "id" : "2121CF71",
    "lastKnownWriteTime" : 1414759936,
    "path" : "~/Dropbox/premod/R/code.R",
    "project_path" : "R/code.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}